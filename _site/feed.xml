<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-06T15:45:10+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">ZWei</title><subtitle>专注于计算科学、材料科学与物理学的学术博客，分享前沿研究见解与专业知识。</subtitle><entry><title type="html">通过 AbiPy 从输入文件中提取优化后的结构</title><link href="http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87-AbiPy-%E4%BB%8E%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84.html" rel="alternate" type="text/html" title="通过 AbiPy 从输入文件中提取优化后的结构" /><published>2025-01-05T00:00:00+01:00</published><updated>2025-01-05T00:00:00+01:00</updated><id>http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87%20AbiPy%20%E4%BB%8E%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84</id><content type="html" xml:base="http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87-AbiPy-%E4%BB%8E%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84.html"><![CDATA[<p>在使用 Abinit 进行结构优化计算后，我们通常需要从输出文件中提取优化后的结构，并将其导出为常见的文件格式（如 CIF 文件）。<code class="language-plaintext highlighter-rouge">AbiPy</code> 是一个强大的 Python 工具库，可以帮助我们轻松实现这一目标。本文将详细介绍如何使用 <code class="language-plaintext highlighter-rouge">AbiPy</code> 从 <code class="language-plaintext highlighter-rouge">.abo</code> 文件中提取优化后的结构，并导出为 CIF 文件。</p>

<h2 id="步骤-1安装-abipy">步骤 1：安装 AbiPy</h2>

<p>首先，确保你已经安装了 <code class="language-plaintext highlighter-rouge">AbiPy</code>。如果尚未安装，可以通过以下命令安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>abipy
</code></pre></div></div>

<h2 id="步骤-2编写-python-脚本">步骤 2：编写 Python 脚本</h2>

<p>接下来，我们需要编写一个 Python 脚本来提取优化后的结构。以下是完整的脚本内容：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">abipy</span> <span class="kn">import</span> <span class="n">abilab</span>

<span class="c1"># 指定 .abo 文件路径
</span><span class="n">abo_file</span> <span class="o">=</span> <span class="sh">"</span><span class="s">input.abo</span><span class="sh">"</span>  <span class="c1"># 替换为你的 .abo 文件名
</span>
<span class="c1"># 使用 abilab.abiopen 打开 .abo 文件
</span><span class="k">with</span> <span class="n">abilab</span><span class="p">.</span><span class="nf">abiopen</span><span class="p">(</span><span class="n">abo_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">abo</span><span class="p">:</span>
    <span class="c1"># 提取优化后的结构
</span>    <span class="n">optimized_structure</span> <span class="o">=</span> <span class="n">abo</span><span class="p">.</span><span class="n">final_structure</span>

    <span class="c1"># 打印优化后的结构信息
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">优化后的结构：</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">optimized_structure</span><span class="p">)</span>

    <span class="c1"># 导出为 CIF 文件
</span>    <span class="n">optimized_structure</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sh">"</span><span class="s">optimized_structure.cif</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">优化后的结构已保存为 optimized_structure.cif</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="脚本说明">脚本说明：</h3>
<ol>
  <li><strong>导入 AbiPy</strong>：<code class="language-plaintext highlighter-rouge">from abipy import abilab</code> 导入 AbiPy 的核心模块。</li>
  <li><strong>指定文件路径</strong>：将 <code class="language-plaintext highlighter-rouge">abo_file</code> 设置为你的 <code class="language-plaintext highlighter-rouge">.abo</code> 文件路径。</li>
  <li><strong>提取结构</strong>：使用 <code class="language-plaintext highlighter-rouge">abilab.abiopen</code> 打开 <code class="language-plaintext highlighter-rouge">.abo</code> 文件，并通过 <code class="language-plaintext highlighter-rouge">abo.final_structure</code> 提取优化后的结构。</li>
  <li><strong>导出为 CIF 文件</strong>：使用 <code class="language-plaintext highlighter-rouge">optimized_structure.to</code> 方法将结构导出为 CIF 文件。</li>
</ol>

<h2 id="步骤-3运行脚本">步骤 3：运行脚本</h2>

<p>将上述脚本保存为 <code class="language-plaintext highlighter-rouge">extract_structure.py</code>，然后在终端中运行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 extract_structure.py
</code></pre></div></div>

<p>运行后，脚本会：</p>
<ol>
  <li>从 <code class="language-plaintext highlighter-rouge">.abo</code> 文件中提取优化后的结构。</li>
  <li>将结构保存为 <code class="language-plaintext highlighter-rouge">optimized_structure.cif</code> 文件。</li>
</ol>

<h2 id="注意事项">注意事项</h2>

<h3 id="1-检查缩进">1. 检查缩进</h3>
<p>Python 对代码缩进非常敏感。确保脚本中的缩进一致：</p>
<ul>
  <li>使用 <strong>4 个空格</strong> 作为缩进。</li>
  <li>避免混用空格和 Tab 键。</li>
</ul>

<p>如果你使用 <code class="language-plaintext highlighter-rouge">vim</code> 编辑器，可以通过以下命令检查缩进：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:set list
</code></pre></div></div>
<p>这将显示不可见字符，帮助你确保所有缩进都是空格。</p>

<h3 id="2-确保-abo-文件存在">2. 确保 <code class="language-plaintext highlighter-rouge">.abo</code> 文件存在</h3>
<p>在运行脚本之前，确保当前目录下存在 <code class="language-plaintext highlighter-rouge">input.abo</code> 文件。你可以通过以下命令检查文件是否存在：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span>
</code></pre></div></div>

<h3 id="3-检查-abipy-安装">3. 检查 AbiPy 安装</h3>
<p>如果运行脚本时提示 <code class="language-plaintext highlighter-rouge">ModuleNotFoundError: No module named 'abipy'</code>，说明 <code class="language-plaintext highlighter-rouge">AbiPy</code> 未正确安装。请通过以下命令重新安装：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>abipy
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>通过 <code class="language-plaintext highlighter-rouge">AbiPy</code>，我们可以轻松地从 <code class="language-plaintext highlighter-rouge">.abo</code> 文件中提取优化后的结构，并将其导出为 CIF 文件。这种方法不仅高效，而且避免了手动提取结构的繁琐过程。如果你经常需要处理 Abinit 的输出文件，<code class="language-plaintext highlighter-rouge">AbiPy</code> 将是一个非常有用的工具。</p>]]></content><author><name></name></author><category term="Abipy" /><summary type="html"><![CDATA[在使用 Abinit 进行结构优化计算后，我们通常需要从输出文件中提取优化后的结构，并将其导出为常见的文件格式（如 CIF 文件）。AbiPy 是一个强大的 Python 工具库，可以帮助我们轻松实现这一目标。本文将详细介绍如何使用 AbiPy 从 .abo 文件中提取优化后的结构，并导出为 CIF 文件。]]></summary></entry><entry><title type="html">通过Abipy生成Ovito或JSmol可视化的结构演变文件</title><link href="http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87-AbiPy%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%87%E4%BB%B6.html" rel="alternate" type="text/html" title="通过Abipy生成Ovito或JSmol可视化的结构演变文件" /><published>2025-01-05T00:00:00+01:00</published><updated>2025-01-05T00:00:00+01:00</updated><id>http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87%20AbiPy%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%87%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/abipy/2025/01/05/%E9%80%9A%E8%BF%87-AbiPy%E6%8F%90%E5%8F%96%E7%BB%93%E6%9E%84%E6%BC%94%E5%8F%98%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%87%E4%BB%B6.html"><![CDATA[<p>生成可以用 <strong>OVITO</strong> 或 <strong>JSmol</strong> 可视化的结构演变文件，而不是静态图片或动画。以下是完整的代码，用于从 <code class="language-plaintext highlighter-rouge">.HIST.nc</code> 文件中提取结构演变数据，并保存为 <strong>XYZ</strong> 或 <strong>CIF</strong> 格式的文件，这些文件可以直接用 OVITO 或 JSmol 进行可视化。</p>

<h3 id="python代码">Python代码</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">abipy</span> <span class="kn">import</span> <span class="n">abilab</span>

<span class="c1"># 指定 HIST.nc 文件路径
</span><span class="n">hist_file</span> <span class="o">=</span> <span class="sh">"</span><span class="s">inputo_HIST.nc</span><span class="sh">"</span>  <span class="c1"># 替换为你的 HIST.nc 文件名
</span>
<span class="c1"># 使用 abilab.abiopen 打开 HIST.nc 文件
</span><span class="k">with</span> <span class="n">abilab</span><span class="p">.</span><span class="nf">abiopen</span><span class="p">(</span><span class="n">hist_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
    <span class="c1"># 打印历史轨迹信息
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">历史轨迹信息：</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>

    <span class="c1"># 提取所有步骤的结构
</span>    <span class="n">structures</span> <span class="o">=</span> <span class="n">hist</span><span class="p">.</span><span class="n">structures</span>  <span class="c1"># 获取所有步骤的结构
</span>    <span class="n">num_steps</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>  <span class="c1"># 获取步骤数
</span>
    <span class="c1"># 保存为 XYZ 文件（适用于 OVITO）
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">正在生成 XYZ 文件...</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">structure_evolution.xyz</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="n">structure</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">structures</span><span class="p">):</span>
            <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 写入原子数
</span>            <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Step </span><span class="si">{</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 写入步骤信息
</span>            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">site</span><span class="p">.</span><span class="n">specie</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">site</span><span class="p">.</span><span class="n">x</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">site</span><span class="p">.</span><span class="n">y</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">site</span><span class="p">.</span><span class="n">z</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 写入原子坐标
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">结构演变已保存为 structure_evolution.xyz</span><span class="sh">"</span><span class="p">)</span>

    <span class="c1"># 保存为 CIF 文件（适用于 JSmol）
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">正在生成 CIF 文件...</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="n">structure</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">structures</span><span class="p">):</span>
        <span class="n">structure</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="sh">"</span><span class="s">structure_step_</span><span class="si">{</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s">.cif</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># 每个步骤保存为一个 CIF 文件
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">结构演变已保存为多个 CIF 文件（每个步骤一个文件）</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="代码说明">代码说明</h3>

<ol>
  <li><strong>保存为 XYZ 文件</strong>：
    <ul>
      <li>XYZ 文件是一种简单的文本格式，适用于 <strong>OVITO</strong>。</li>
      <li>每个步骤的结构会被写入到 <code class="language-plaintext highlighter-rouge">structure_evolution.xyz</code> 文件中。</li>
      <li>文件格式：
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>29
Step 1
Al 0.0 0.0 0.319292
Al 0.0 0.5 0.319292
...
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>保存为 CIF 文件</strong>：
    <ul>
      <li>CIF 文件是一种常见的晶体结构文件格式，适用于 <strong>JSmol</strong>。</li>
      <li>每个步骤的结构会被保存为一个单独的 CIF 文件，文件名为 <code class="language-plaintext highlighter-rouge">structure_step_1.cif</code>、<code class="language-plaintext highlighter-rouge">structure_step_2.cif</code> 等。</li>
    </ul>
  </li>
</ol>

<h3 id="运行脚本">运行脚本</h3>

<p>将上述脚本保存为 <code class="language-plaintext highlighter-rouge">visualize_evolution.py</code>，然后在终端中运行：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 visualize_evolution.py
</code></pre></div></div>

<h3 id="输出文件">输出文件</h3>

<p>运行脚本后，当前目录下会生成以下文件：</p>
<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">structure_evolution.xyz</code></strong>：包含所有步骤的结构演变数据，适用于 OVITO。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">structure_step_1.cif</code>、<code class="language-plaintext highlighter-rouge">structure_step_2.cif</code>、…</strong>：每个步骤的结构保存为单独的 CIF 文件，适用于 JSmol。</li>
</ol>

<h3 id="使用-ovito-可视化-xyz-文件">使用 OVITO 可视化 XYZ 文件</h3>

<ol>
  <li>打开 <strong>OVITO</strong>。</li>
  <li>选择 <code class="language-plaintext highlighter-rouge">File -&gt; Load File</code>，加载 <code class="language-plaintext highlighter-rouge">structure_evolution.xyz</code>。</li>
  <li>在 OVITO 中，你可以通过时间轴查看结构演变过程。</li>
</ol>

<h3 id="使用-jsmol-可视化-cif-文件">使用 JSmol 可视化 CIF 文件</h3>

<ol>
  <li>将生成的 CIF 文件上传到支持 JSmol 的网站（如 <a href="https://chemapps.stolaf.edu/jmol/">JSmol 官网</a>）。</li>
  <li>加载 CIF 文件后，可以通过切换文件查看不同步骤的结构。</li>
</ol>

<h3 id="注意事项">注意事项</h3>

<ol>
  <li><strong>确保 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件存在</strong>：
    <ul>
      <li>确保 Abinit 计算中启用了历史轨迹输出（通过设置 <code class="language-plaintext highlighter-rouge">prtvol</code> 和 <code class="language-plaintext highlighter-rouge">ionmov</code> 等参数）。</li>
    </ul>
  </li>
  <li><strong>依赖安装</strong>：
    <ul>
      <li>如果运行脚本时提示缺少依赖（如 <code class="language-plaintext highlighter-rouge">abipy</code>），请通过以下命令安装：
        <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>abipy
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>文件格式</strong>：
    <ul>
      <li>XYZ 文件适用于 OVITO，而 CIF 文件适用于 JSmol。根据你的需求选择合适的格式。</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="Abipy" /><summary type="html"><![CDATA[生成可以用 OVITO 或 JSmol 可视化的结构演变文件，而不是静态图片或动画。以下是完整的代码，用于从 .HIST.nc 文件中提取结构演变数据，并保存为 XYZ 或 CIF 格式的文件，这些文件可以直接用 OVITO 或 JSmol 进行可视化。]]></summary></entry><entry><title type="html">Abinit变量istwfk</title><link href="http://localhost:4000/abinit%20variables/2025/01/02/Abinit%E5%8F%98%E9%87%8Fistwfk.html" rel="alternate" type="text/html" title="Abinit变量istwfk" /><published>2025-01-02T00:00:00+01:00</published><updated>2025-01-02T00:00:00+01:00</updated><id>http://localhost:4000/abinit%20variables/2025/01/02/Abinit%E5%8F%98%E9%87%8Fistwfk</id><content type="html" xml:base="http://localhost:4000/abinit%20variables/2025/01/02/Abinit%E5%8F%98%E9%87%8Fistwfk.html"><![CDATA[<p>在ABINIT软件中，<code class="language-plaintext highlighter-rouge">istwfk</code> 是一个用于控制每个k点波函数存储方式的参数。它决定了是否利用时间反演对称性来优化波函数在倒空间中的存储，从而减少计算所需的平面波数量。</p>

<hr />

<h3 id="istwfk-的详细说明"><code class="language-plaintext highlighter-rouge">istwfk</code> 的详细说明</h3>

<ol>
  <li><strong>参数类型</strong>：
    <ul>
      <li><strong>变量类型</strong>：整数（integer）</li>
      <li><strong>维度</strong>：<code class="language-plaintext highlighter-rouge">(nkpt)</code>，其中 <code class="language-plaintext highlighter-rouge">nkpt</code> 是k点的数量。</li>
    </ul>
  </li>
  <li><strong>默认值</strong>：
    <ul>
      <li><strong>默认值</strong>：0</li>
      <li><strong>特殊情况</strong>：
        <ul>
          <li>对于响应函数（RF）计算，<code class="language-plaintext highlighter-rouge">istwfk</code> 会被强制设置为1，适用于所有k点。</li>
          <li>对于自旋轨道耦合计算（<code class="language-plaintext highlighter-rouge">nspinor = 2</code>），<code class="language-plaintext highlighter-rouge">istwfk</code> 也会被强制设置为1，适用于所有k点。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>作用</strong>：
    <ul>
      <li>控制每个k点的波函数在倒空间中的存储方式。</li>
      <li>对于基态（GS）计算，波函数系数存储在 <code class="language-plaintext highlighter-rouge">cg</code> 数组中，每个k点和每个能带对应一个段 <code class="language-plaintext highlighter-rouge">cg(1:2, 1:npw)</code>，其中 <code class="language-plaintext highlighter-rouge">npw</code> 是平面波的数量。</li>
      <li>如果k点坐标仅由0和1/2组成（例如 <code class="language-plaintext highlighter-rouge">(0, 0, 0)</code>、<code class="language-plaintext highlighter-rouge">(½, 0, 0)</code> 等），可以利用时间反演对称性来减少需要显式处理的平面波数量，从而使用实数到复数的FFT（见 <code class="language-plaintext highlighter-rouge">fftalg</code>）。</li>
    </ul>
  </li>
  <li><strong>选项说明</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 1</code></strong>：<strong>不使用</strong>时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 2</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (0, 0, 0)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 3</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (½, 0, 0)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 4</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (0, 0, ½)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 5</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (½, 0, ½)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 6</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (0, ½, 0)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 7</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (½, ½, 0)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 8</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (0, ½, ½)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 9</code></strong>：对 <code class="language-plaintext highlighter-rouge">k = (½, ½, ½)</code> 使用时间反演对称性。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">istwfk = 0</code></strong>：<strong>自动选择</strong>。对于每个k点，如果允许使用时间反演对称性，则自动选择适当的选项；否则，设置为 <code class="language-plaintext highlighter-rouge">istwfk = 1</code>。</li>
    </ul>
  </li>
  <li><strong>响应函数（RF）计算的限制</strong>：
    <ul>
      <li>对于RF计算，除了 <code class="language-plaintext highlighter-rouge">cg</code> 数组外，还有 <code class="language-plaintext highlighter-rouge">cgq</code> 和 <code class="language-plaintext highlighter-rouge">cg1</code> 数组。</li>
      <li>要利用时间反演对称性减少这些数组的平面波数量，q向量必须为 <code class="language-plaintext highlighter-rouge">(0, 0, 0)</code>。</li>
      <li>目前，时间反演对称性<strong>不能</strong>用于RF计算。</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="示例">示例</h3>

<p>假设你有一个k点列表，其中包含 <code class="language-plaintext highlighter-rouge">(0, 0, 0)</code> 和 <code class="language-plaintext highlighter-rouge">(½, 0, 0)</code>，你可以在输入文件中设置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istwfk 2 3
</code></pre></div></div>

<p>这表示：</p>
<ul>
  <li>对 <code class="language-plaintext highlighter-rouge">k = (0, 0, 0)</code> 使用时间反演对称性（<code class="language-plaintext highlighter-rouge">istwfk = 2</code>）。</li>
  <li>对 <code class="language-plaintext highlighter-rouge">k = (½, 0, 0)</code> 使用时间反演对称性（<code class="language-plaintext highlighter-rouge">istwfk = 3</code>）。</li>
</ul>

<p>如果希望ABINIT自动选择，可以设置为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istwfk 0
</code></pre></div></div>
<hr />

<h3 id="问什么是响应函数计算什么是时间反演对称性">问：什么是响应函数计算？什么是时间反演对称性？</h3>

<hr />
<h3 id="1-响应函数计算response-function-calculation">1. <strong>响应函数计算（Response Function Calculation）</strong></h3>

<p>响应函数计算是研究材料对外部微扰（如电场、磁场或声子扰动）的线性响应的理论方法。它在密度泛函理论（DFT）框架下用于计算材料的电子、光学和晶格动力学性质。</p>

<h4 id="核心概念"><strong>核心概念</strong>：</h4>
<ul>
  <li><strong>微扰理论</strong>：假设外部微扰足够小，系统的响应可以通过线性近似来描述。</li>
  <li><strong>响应函数</strong>：描述系统对外部微扰的响应，例如：
    <ul>
      <li><strong>介电函数</strong>：材料对电场的响应。</li>
      <li><strong>磁化率</strong>：材料对磁场的响应。</li>
      <li><strong>声子谱</strong>：晶格对原子位移的响应。</li>
    </ul>
  </li>
</ul>

<h4 id="应用"><strong>应用</strong>：</h4>
<ul>
  <li><strong>光学性质</strong>：计算材料的吸收光谱、折射率等。</li>
  <li><strong>晶格动力学</strong>：计算声子谱和声子态密度。</li>
  <li><strong>电子激发</strong>：研究电子-电子相互作用和激发态性质。</li>
</ul>

<h4 id="abinit中的响应函数计算"><strong>ABINIT中的响应函数计算</strong>：</h4>
<ul>
  <li>在ABINIT中，响应函数计算通过特定的输入参数和数据集实现。</li>
  <li>涉及的关键变量包括 <code class="language-plaintext highlighter-rouge">irdwfk</code>、<code class="language-plaintext highlighter-rouge">getwfk</code> 和 <code class="language-plaintext highlighter-rouge">istwfk</code>。</li>
  <li>响应函数计算通常需要更多的计算资源和存储空间，因为需要处理额外的波函数和矩阵元。</li>
</ul>

<hr />

<h3 id="2-时间反演对称性time-reversal-symmetry">2. <strong>时间反演对称性（Time-Reversal Symmetry）</strong></h3>

<p>时间反演对称性是物理学中的一种对称性，描述系统在时间反演操作下的行为。时间反演操作是将时间 $t$ 替换为 $-t$。</p>

<h4 id="核心概念-1"><strong>核心概念</strong>：</h4>
<ul>
  <li><strong>时间反演操作</strong>：将系统的运动方向反转，例如将粒子的速度反向。</li>
  <li><strong>时间反演对称性</strong>：如果系统在时间反演操作下保持不变，则称其具有时间反演对称性。</li>
  <li>
    <p><strong>数学表示</strong>：在量子力学中，时间反演算符 $\mathcal{T}$ 作用于波函数 $\psi(\mathbf{r}, t)$ 时，满足：</p>

\[\mathcal{T} \psi(\mathbf{r}, t) = \psi^*(\mathbf{r}, -t)\]

    <p>其中 $\psi^*$ 是波函数的复共轭。</p>
  </li>
</ul>

<h4 id="在固体物理中的应用"><strong>在固体物理中的应用</strong>：</h4>
<ul>
  <li><strong>k空间对称性</strong>：在倒空间中，时间反演对称性将波矢 $\mathbf{k}$ 映射为 $-\mathbf{k}$。</li>
  <li><strong>平面波减少</strong>：对于某些k点（如 $\mathbf{k} = (0, 0, 0)$ 或 $\mathbf{k} = (\frac{1}{2}, 0, 0)$），可以利用时间反演对称性将平面波数量减半，从而减少计算量。</li>
  <li><strong>自旋轨道耦合</strong>：在自旋轨道耦合系统中，时间反演对称性可能导致能级简并（Kramers简并）。</li>
</ul>

<h4 id="在abinit中的应用"><strong>在ABINIT中的应用</strong>：</h4>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">istwfk</code> 参数</strong>：控制是否利用时间反演对称性来优化波函数的存储和计算。</li>
  <li><strong>限制</strong>：
    <ul>
      <li>对于响应函数计算，时间反演对称性通常不能使用（<code class="language-plaintext highlighter-rouge">istwfk</code> 被强制设置为1）。</li>
      <li>对于自旋轨道耦合计算，时间反演对称性也不能使用（<code class="language-plaintext highlighter-rouge">istwfk</code> 被强制设置为1）。</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="ABINIT variables" /><summary type="html"><![CDATA[在ABINIT软件中，istwfk 是一个用于控制每个k点波函数存储方式的参数。它决定了是否利用时间反演对称性来优化波函数在倒空间中的存储，从而减少计算所需的平面波数量。]]></summary></entry><entry><title type="html">Abinit中的文件名</title><link href="http://localhost:4000/abinit%20tutorials/2025/01/01/Abinit%E6%96%87%E4%BB%B6%E5%90%8D.html" rel="alternate" type="text/html" title="Abinit中的文件名" /><published>2025-01-01T00:00:00+01:00</published><updated>2025-01-01T00:00:00+01:00</updated><id>http://localhost:4000/abinit%20tutorials/2025/01/01/Abinit%E6%96%87%E4%BB%B6%E5%90%8D</id><content type="html" xml:base="http://localhost:4000/abinit%20tutorials/2025/01/01/Abinit%E6%96%87%E4%BB%B6%E5%90%8D.html"><![CDATA[<p>在ABINIT中，文件名的生成方式有两种：一种是ABINIT自动生成，另一种是基于输入变量（如 <code class="language-plaintext highlighter-rouge">output_file</code>、<code class="language-plaintext highlighter-rouge">pseudos</code>、<code class="language-plaintext highlighter-rouge">indata_prefix</code>、<code class="language-plaintext highlighter-rouge">outdata_prefix</code> 或 <code class="language-plaintext highlighter-rouge">tmpdata_prefix</code>）构建。以下是关于ABINIT文件名的详细说明：</p>

<hr />

<h3 id="1-output_file">1. <strong><code class="language-plaintext highlighter-rouge">output_file</code></strong></h3>
<ul>
  <li><strong>作用</strong>：指定主输出文件的文件名。</li>
  <li><strong>说明</strong>：
    <ul>
      <li>主输出文件包含格式化的输出信息。</li>
      <li>错误消息和其他诊断信息不会写入此文件，而是发送到单元06（终端或日志文件）。</li>
      <li>单元06的输出可以在运行成功时忽略，主输出文件则以更美观的格式记录运行信息。</li>
    </ul>
  </li>
  <li><strong>示例</strong>：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output_file "my_output.out"
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="2-pseudos">2. <strong><code class="language-plaintext highlighter-rouge">pseudos</code></strong></h3>
<ul>
  <li><strong>作用</strong>：指定伪势文件的文件名。</li>
  <li><strong>说明</strong>：
    <ul>
      <li>伪势文件是格式化的输入文件。</li>
      <li>必须为系统中的每种原子类型提供一个文件名，顺序与 <code class="language-plaintext highlighter-rouge">typat</code> 中列出的原子类型一致。</li>
    </ul>
  </li>
  <li><strong>示例</strong>：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pseudos "H.psp8, O.psp8"
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="3-abi-或-indata_prefix">3. <strong><code class="language-plaintext highlighter-rouge">abi</code> 或 <code class="language-plaintext highlighter-rouge">indata_prefix</code></strong></h3>
<ul>
  <li><strong>作用</strong>：构建读取文件的文件名。</li>
  <li><strong>说明</strong>：
    <ul>
      <li>其他由代码读取的文件名基于根名称 <code class="language-plaintext highlighter-rouge">abi</code> 或 <code class="language-plaintext highlighter-rouge">indata_prefix</code> 构建。</li>
      <li>在多数据集模式下，根名称会附加 <code class="language-plaintext highlighter-rouge">_DS</code> 和数据集索引。</li>
    </ul>
  </li>
  <li><strong>常见文件</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">abi_WFK</code>：包含输入波函数系数的文件（<code class="language-plaintext highlighter-rouge">irdwfk=1</code> 时读取）。</li>
      <li><code class="language-plaintext highlighter-rouge">abi_WFQ</code>：包含输入波函数系数的文件（用于响应函数计算）。</li>
      <li><code class="language-plaintext highlighter-rouge">abi_1WFxx</code>：包含一阶波函数的文件（<code class="language-plaintext highlighter-rouge">xx</code> 是扰动索引）。</li>
      <li><code class="language-plaintext highlighter-rouge">abi_DEN</code>：包含密度的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abi_HES</code>：包含近似Hessian矩阵的文件（用于Broyden最小化初始化）。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="4-abo-或-outdata_prefix">4. <strong><code class="language-plaintext highlighter-rouge">abo</code> 或 <code class="language-plaintext highlighter-rouge">outdata_prefix</code></strong></h3>
<ul>
  <li><strong>作用</strong>：构建写入文件的文件名。</li>
  <li><strong>说明</strong>：
    <ul>
      <li>其他由代码写入的文件名基于根名称 <code class="language-plaintext highlighter-rouge">abo</code> 或 <code class="language-plaintext highlighter-rouge">outdata_prefix</code> 构建。</li>
      <li>在多数据集模式下，根名称会附加 <code class="language-plaintext highlighter-rouge">_DS</code> 和数据集索引。</li>
    </ul>
  </li>
  <li><strong>常见文件</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">abo_WFK</code>：包含输出波函数系数的文件（<code class="language-plaintext highlighter-rouge">nqpt=0</code>）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_WFQ</code>：包含输出波函数系数的文件（<code class="language-plaintext highlighter-rouge">nqpt=1</code>）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_1WFxx</code>：包含一阶波函数的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_DDB</code>：导数数据库文件（由响应函数数据集生成）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_DEN</code>：包含密度的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_TIMx_DEN</code>：包含密度的文件（<code class="language-plaintext highlighter-rouge">ionmov/=0</code> 时生成）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_POT</code>：包含Kohn-Sham势的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_TIMx_POT</code>：包含Kohn-Sham势的文件（<code class="language-plaintext highlighter-rouge">ionmov/=0</code> 时生成）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_DOS</code>：包含态密度的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_TIMx_DOS</code>：包含态密度的文件（<code class="language-plaintext highlighter-rouge">prtdos=2</code> 且 <code class="language-plaintext highlighter-rouge">ionmov=1</code> 或 <code class="language-plaintext highlighter-rouge">2</code> 时生成）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_GEO</code>：包含几何分析（键长和键角）的文件。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_TIMx_GEO</code>：包含几何分析的文件（<code class="language-plaintext highlighter-rouge">ionmov=1</code> 或 <code class="language-plaintext highlighter-rouge">2</code> 时生成）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_KSS</code>：包含输出波函数系数的文件（用于GW计算）。</li>
      <li><code class="language-plaintext highlighter-rouge">abo_EIG</code>：包含电子本征值的文件（用于绘制能带结构）。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="5-tmp-或-tmpdata_prefix">5. <strong><code class="language-plaintext highlighter-rouge">tmp</code> 或 <code class="language-plaintext highlighter-rouge">tmpdata_prefix</code></strong></h3>
<ul>
  <li><strong>作用</strong>：构建临时文件的文件名。</li>
  <li><strong>说明</strong>：
    <ul>
      <li>临时文件基于根名称 <code class="language-plaintext highlighter-rouge">tmp</code> 或 <code class="language-plaintext highlighter-rouge">tmpdata_prefix</code> 构建。</li>
      <li>通常应选择本地磁盘（而非远程NFS磁盘）来存储临时文件。</li>
    </ul>
  </li>
  <li><strong>示例</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tmp_STATUS</code>：记录计算进度的文件，更新频率很高。</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="6-文件名中的-timx">6. <strong>文件名中的 <code class="language-plaintext highlighter-rouge">TIMx</code></strong></h3>
<ul>
  <li><strong>作用</strong>：在 <code class="language-plaintext highlighter-rouge">ionmov/=0</code> 时，为每次SCF循环生成的文件提供不同的名称。</li>
  <li><strong>说明</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x</code> 的取值规则：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ionmov==1</code>：初始化阶段有4次SCF调用，<code class="language-plaintext highlighter-rouge">x</code> 为 <code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>、<code class="language-plaintext highlighter-rouge">C</code>、<code class="language-plaintext highlighter-rouge">D</code>，之后为 <code class="language-plaintext highlighter-rouge">1</code>、<code class="language-plaintext highlighter-rouge">2</code>、<code class="language-plaintext highlighter-rouge">3</code>…。</li>
          <li>其他 <code class="language-plaintext highlighter-rouge">ionmov</code> 情况：初始化阶段有1次SCF调用，<code class="language-plaintext highlighter-rouge">x</code> 为 <code class="language-plaintext highlighter-rouge">0</code>，之后为 <code class="language-plaintext highlighter-rouge">1</code>、<code class="language-plaintext highlighter-rouge">2</code>、<code class="language-plaintext highlighter-rouge">3</code>…。</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="总结">总结</h3>
<p>ABINIT中的文件名生成规则非常灵活，用户可以通过 <code class="language-plaintext highlighter-rouge">output_file</code>、<code class="language-plaintext highlighter-rouge">pseudos</code>、<code class="language-plaintext highlighter-rouge">indata_prefix</code>、<code class="language-plaintext highlighter-rouge">outdata_prefix</code> 和 <code class="language-plaintext highlighter-rouge">tmpdata_prefix</code> 等参数自定义文件名。理解这些规则有助于更好地管理输入和输出文件，特别是在多数据集模式或复杂计算任务中。</p>]]></content><author><name></name></author><category term="ABINIT tutorials" /><summary type="html"><![CDATA[在ABINIT中，文件名的生成方式有两种：一种是ABINIT自动生成，另一种是基于输入变量（如 output_file、pseudos、indata_prefix、outdata_prefix 或 tmpdata_prefix）构建。以下是关于ABINIT文件名的详细说明：]]></summary></entry><entry><title type="html">Abinit变量restartxf</title><link href="http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Frestartxf.html" rel="alternate" type="text/html" title="Abinit变量restartxf" /><published>2025-01-01T00:00:00+01:00</published><updated>2025-01-01T00:00:00+01:00</updated><id>http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Frestartxf</id><content type="html" xml:base="http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Frestartxf.html"><![CDATA[<p>在ABINIT软件中，<code class="language-plaintext highlighter-rouge">restartxf</code> 是一个用于控制分子动力学（Molecular Dynamics, MD）或结构优化（Structural Optimization）任务重启行为的参数。它允许用户从历史文件（如 <code class="language-plaintext highlighter-rouge">HIST.nc</code>）中恢复计算，而不是从头开始。</p>

<h3 id="restartxf-的详细说明"><code class="language-plaintext highlighter-rouge">restartxf</code> 的详细说明</h3>

<ol>
  <li><strong>参数类型</strong>：
    <ul>
      <li><strong>变量类型</strong>：整数（integer）</li>
      <li><strong>维度</strong>：标量（scalar）</li>
    </ul>
  </li>
  <li><strong>默认值</strong>：
    <ul>
      <li><strong>默认值</strong>：0</li>
    </ul>
  </li>
  <li><strong>使用场景</strong>：
    <ul>
      <li>用于控制分子动力学或结构优化任务的重启行为。</li>
    </ul>
  </li>
  <li><strong>选项说明</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">restartxf = 0</code></strong>（默认值）：
        <ul>
          <li>不启用重启功能，代码将从头开始进行分子动力学或结构优化计算。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">restartxf = -1</code></strong>（新选项）：
        <ul>
          <li>使用 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件重建部分计算。它将使用 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件中存储的力和应力来重建不同的配置，而不是调用自洽场（SCF）过程。</li>
          <li>从开始就使用 <code class="language-plaintext highlighter-rouge">restartxf = -1</code> 是无害的，唯一条件是保持输入文件不变，以便使用相同的预测器，并预测与 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件中记录的结构相同的结构。</li>
          <li>此选项将始终计算额外的 <code class="language-plaintext highlighter-rouge">ntime</code> 次迭代，与之前恢复的迭代次数无关。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">restartxf = -2</code></strong>（新选项）：
        <ul>
          <li>读取 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件并选择具有最低能量的原子位置和晶胞参数。忽略所有历史记录，并使用这些值开始计算。在这种情况下，原始的原子坐标和晶胞参数无关紧要。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">restartxf = -3</code></strong>（新选项）：
        <ul>
          <li>仅读取 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件中最后所需的原子位置和晶胞参数，以重启分子动力学或结构优化。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>注意事项</strong>：
    <ul>
      <li>你可以使用 <code class="language-plaintext highlighter-rouge">restartxf = -1</code>、<code class="language-plaintext highlighter-rouge">-2</code> 或 <code class="language-plaintext highlighter-rouge">-3</code> 来重启不使用随机数的预测器的计算。</li>
      <li>你可以使用 <code class="language-plaintext highlighter-rouge">restartxf = -1</code>、<code class="language-plaintext highlighter-rouge">-2</code> 或 <code class="language-plaintext highlighter-rouge">-3</code> 来重启未完成的计算。<code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件在每次迭代时都会写入，因此你总是可以从中恢复。</li>
      <li>你可以利用 <code class="language-plaintext highlighter-rouge">irdwfk</code> 或 <code class="language-plaintext highlighter-rouge">getwfk</code> 的适当值来获得一个良好的波函数以继续你的工作。</li>
      <li>在ABINITv8之前，允许使用 <code class="language-plaintext highlighter-rouge">restartxf</code> 的正值，但这些选项已被弃用。</li>
    </ul>
  </li>
</ol>

<h3 id="示例">示例</h3>

<p>假设你有一个未完成的分子动力学计算，并且你希望从 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件中恢复计算，你可以在输入文件中添加以下行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>restartxf -1
</code></pre></div></div>

<p>这样，ABINIT将使用 <code class="language-plaintext highlighter-rouge">HIST.nc</code> 文件中的信息来重建计算，并继续进行计算。</p>

<h3 id="总结">总结</h3>

<p><code class="language-plaintext highlighter-rouge">restartxf</code> 参数为用户提供了灵活的重启选项，允许他们从历史文件中恢复分子动力学或结构优化计算。这对于处理未完成的计算或优化计算过程非常有用。通过选择合适的 <code class="language-plaintext highlighter-rouge">restartxf</code> 值，用户可以有效地管理和继续他们的计算任务。</p>]]></content><author><name></name></author><category term="ABINIT variables" /><summary type="html"><![CDATA[在ABINIT软件中，restartxf 是一个用于控制分子动力学（Molecular Dynamics, MD）或结构优化（Structural Optimization）任务重启行为的参数。它允许用户从历史文件（如 HIST.nc）中恢复计算，而不是从头开始。]]></summary></entry><entry><title type="html">Abinit变量ngfft</title><link href="http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Fngfft.html" rel="alternate" type="text/html" title="Abinit变量ngfft" /><published>2025-01-01T00:00:00+01:00</published><updated>2025-01-01T00:00:00+01:00</updated><id>http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Fngfft</id><content type="html" xml:base="http://localhost:4000/abinit%20variables/2025/01/01/Abinit%E5%8F%98%E9%87%8Fngfft.html"><![CDATA[<p>在ABINIT软件中，<code class="language-plaintext highlighter-rouge">ngfft</code> 是一个用于定义快速傅里叶变换（FFT）网格大小的参数。它决定了在三个维度上FFT网格的点数，直接影响计算的精度和效率。</p>

<hr />

<h3 id="ngfft-的详细说明"><code class="language-plaintext highlighter-rouge">ngfft</code> 的详细说明</h3>

<ol>
  <li><strong>参数类型</strong>：
    <ul>
      <li><strong>变量类型</strong>：整数（integer）</li>
      <li><strong>维度</strong>：3维数组（<code class="language-plaintext highlighter-rouge">(3)</code>）</li>
    </ul>
  </li>
  <li><strong>默认值</strong>：
    <ul>
      <li><strong>默认值</strong>：<code class="language-plaintext highlighter-rouge">[0, 0, 0]</code></li>
      <li>如果未提供 <code class="language-plaintext highlighter-rouge">ngfft</code> 或其值为 <code class="language-plaintext highlighter-rouge">[0, 0, 0]</code>，ABINIT会根据 <code class="language-plaintext highlighter-rouge">acell</code>、<code class="language-plaintext highlighter-rouge">rprim</code> 和 <code class="language-plaintext highlighter-rouge">ecut</code> 自动选择最优的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值。这是推荐的做法。</li>
    </ul>
  </li>
  <li><strong>作用</strong>：
    <ul>
      <li>定义FFT网格在三个维度上的点数。</li>
      <li>每个维度的点数必须是2、3、5的乘积，以与ABINIT中FFT的基数兼容。</li>
      <li>总FFT点数为：<code class="language-plaintext highlighter-rouge">ngfft(1) × ngfft(2) × ngfft(3) = %nfft</code>。</li>
    </ul>
  </li>
  <li><strong>优化与近似</strong>：
    <ul>
      <li>如果手动设置 <code class="language-plaintext highlighter-rouge">ngfft</code> 的值小于推荐值（例如通过设置 <code class="language-plaintext highlighter-rouge">boxcutmin</code> 小于2.0），代码会运行得更快，但方程会通过低通傅里叶滤波器进行近似。</li>
      <li>代码会输出一个参数 <code class="language-plaintext highlighter-rouge">boxcut</code>，表示FFT盒子边长与倒空间向量基球直径的最小比值：
        <ul>
          <li>当 <code class="language-plaintext highlighter-rouge">boxcut &lt; 2</code> 时，使用了傅里叶滤波器近似。</li>
          <li>当 <code class="language-plaintext highlighter-rouge">boxcut &lt; 1.5</code> 时，近似可能过于粗糙，结果可能不准确，建议测试更大的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值。</li>
          <li>当 <code class="language-plaintext highlighter-rouge">boxcut &gt; 2</code> 时，可以减少 <code class="language-plaintext highlighter-rouge">ngfft</code> 而不损失精度。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>内部存储</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ngfft</code> 在内部是一个大小为18的数组，其中：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ngfft(1:3)</code>：存储用户定义的或自动选择的FFT网格点数。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(4:6)</code>：存储稍大（修改后）的值，以提高FFT效率。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(7)</code>：存储 <code class="language-plaintext highlighter-rouge">fftalg</code>（FFT算法选择）。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(8)</code>：存储 <code class="language-plaintext highlighter-rouge">fftcache</code>（FFT缓存设置）。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(9)</code>：指示FFT并行化是否激活（0：未激活，1：激活）。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(10)</code>：FFT组的处理器数量。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(11)</code>：处理器在组中的索引。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(12)</code>：<code class="language-plaintext highlighter-rouge">n2proc</code>，倒空间中每个处理器处理的x-z平面数量。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(13)</code>：<code class="language-plaintext highlighter-rouge">n3proc</code>，实空间中每个处理器处理的x-y平面数量。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(14)</code>：<code class="language-plaintext highlighter-rouge">mpi_comm_fft</code>，负责FFT并行化的MPI通信器句柄。</li>
          <li><code class="language-plaintext highlighter-rouge">ngfft(15:18)</code>：尚未使用。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>存储点数</strong>：
    <ul>
      <li>在实空间中，每个处理器存储的点数为：<code class="language-plaintext highlighter-rouge">n1 × n2 × n3proc</code>。</li>
      <li>在倒空间中，每个处理器存储的点数为：<code class="language-plaintext highlighter-rouge">n1 × n2proc × n3</code>。</li>
    </ul>
  </li>
</ol>

<h3 id="示例">示例</h3>

<p>假设你希望手动设置FFT网格点数，可以在输入文件中添加以下行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ngfft 24 24 24
</code></pre></div></div>

<p>这将设置FFT网格在每个维度上的点数为24。</p>

<hr />

<h3 id="问abinit怎样根据-acellrprim-和-ecut-计算并自动选择最优的-ngfft-值的">问：ABINIT怎样根据 acell、rprim 和 ecut 计算并自动选择最优的 ngfft 值的？</h3>

<hr />

<p>当未提供 <code class="language-plaintext highlighter-rouge">ngfft</code> 或其值为 <code class="language-plaintext highlighter-rouge">[0, 0, 0]</code> 时，ABINIT会根据以下输入参数自动计算最优的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值：</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">acell</code></strong>：晶胞的初始尺寸（以玻尔半径为单位）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">rprim</code></strong>：晶胞的基向量（定义晶胞的形状和方向）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ecut</code></strong>：平面波截断能量（以哈特里为单位）。</li>
</ol>

<p>ABINIT通过以下步骤自动选择最优的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值：</p>

<h3 id="1-计算倒空间中的最大波矢">1. <strong>计算倒空间中的最大波矢</strong></h3>
<ul>
  <li>
    <p>根据 <code class="language-plaintext highlighter-rouge">ecut</code> 和平面波的动能公式：</p>

\[\frac{\hbar^2 |\mathbf{G}|^2}{2m} \leq \text{ecut}\]

    <p>其中 $\mathbf{G}$ 是倒格矢，$m$ 是电子质量。</p>
  </li>
  <li>
    <p>由此可以确定倒空间中最大波矢的长度 $|\mathbf{G}|_{\text{max}}$。</p>
  </li>
</ul>

<h3 id="2-确定实空间中的最小网格间距">2. <strong>确定实空间中的最小网格间距</strong></h3>
<ul>
  <li>根据 Nyquist 采样定理，实空间中的网格间距 $\Delta r$ 必须满足：
\(\Delta r \leq \frac{\pi}{|\mathbf{G}|_{\text{max}}}\)
以确保能够准确表示倒空间中的最高频率分量。</li>
</ul>

<h3 id="3-计算每个维度上的网格点数">3. <strong>计算每个维度上的网格点数</strong></h3>
<ul>
  <li>根据晶胞的尺寸（<code class="language-plaintext highlighter-rouge">acell</code> 和 <code class="language-plaintext highlighter-rouge">rprim</code>）和最小网格间距 $\Delta r$，计算每个维度上的网格点数：
\(\text{ngfft}(i) = \frac{\text{acell}(i) \cdot \text{rprim}(i)}{\Delta r}\)
其中 $i = 1, 2, 3$ 表示三个维度。</li>
  <li>为了满足FFT算法的要求，<code class="language-plaintext highlighter-rouge">ngfft(i)</code> 必须是2、3、5的乘积。因此，ABINIT会将计算值向上取整到最近的满足条件的整数。</li>
</ul>

<h3 id="4-考虑-boxcutmin-参数">4. <strong>考虑 <code class="language-plaintext highlighter-rouge">boxcutmin</code> 参数</strong></h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">boxcutmin</code> 是一个用户可调参数，用于控制FFT网格的最小尺寸与倒空间基球直径的比值。</li>
  <li>默认情况下，<code class="language-plaintext highlighter-rouge">boxcutmin = 2.0</code>，这意味着FFT网格的尺寸至少是倒空间基球直径的两倍，以确保高精度。</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">boxcutmin</code> 设置为较小的值（如1.5），ABINIT会选择更小的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值，从而加快计算速度，但会引入傅里叶滤波器近似，可能降低精度。</li>
</ul>

<h3 id="5-输出-boxcut-参数">5. <strong>输出 <code class="language-plaintext highlighter-rouge">boxcut</code> 参数</strong></h3>
<ul>
  <li>ABINIT会计算并输出 <code class="language-plaintext highlighter-rouge">boxcut</code> 参数，表示FFT网格尺寸与倒空间基球直径的实际比值：
\(\text{boxcut} = \frac{\text{FFT网格尺寸}}{\text{倒空间基球直径}}\)</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">boxcut &lt; 2</code>，说明使用了傅里叶滤波器近似；如果 <code class="language-plaintext highlighter-rouge">boxcut &lt; 1.5</code>，近似可能过于粗糙，建议测试更大的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值。</li>
</ul>

<h3 id="6-优化fft效率">6. <strong>优化FFT效率</strong></h3>
<ul>
  <li>ABINIT会进一步调整 <code class="language-plaintext highlighter-rouge">ngfft</code> 的值，以提高FFT计算的效率。例如，选择稍大的 <code class="language-plaintext highlighter-rouge">ngfft</code> 值，以便更好地利用缓存和并行计算资源。</li>
</ul>

<h3 id="总结">总结</h3>

<p>ABINIT自动选择 <code class="language-plaintext highlighter-rouge">ngfft</code> 的过程基于以下原则：</p>
<ol>
  <li>确保FFT网格能够准确表示倒空间中的最高频率分量（由 <code class="language-plaintext highlighter-rouge">ecut</code> 决定）。</li>
  <li>满足FFT算法的基数要求（2、3、5的乘积）。</li>
  <li>考虑 <code class="language-plaintext highlighter-rouge">boxcutmin</code> 参数，在精度和速度之间进行权衡。</li>
  <li>优化FFT计算的效率。</li>
</ol>

<p>这种自动选择机制是推荐的，因为它能够根据输入参数动态调整 <code class="language-plaintext highlighter-rouge">ngfft</code>，确保计算的精度和效率。如果需要手动设置 <code class="language-plaintext highlighter-rouge">ngfft</code>，建议先运行自动选择机制，参考其输出的 <code class="language-plaintext highlighter-rouge">boxcut</code> 值，再进行调整。</p>]]></content><author><name></name></author><category term="ABINIT variables" /><summary type="html"><![CDATA[在ABINIT软件中，ngfft 是一个用于定义快速傅里叶变换（FFT）网格大小的参数。它决定了在三个维度上FFT网格的点数，直接影响计算的精度和效率。]]></summary></entry><entry><title type="html">如何在Cursor中安装DeepSeek模型</title><link href="http://localhost:4000/ai%20tools/2024/12/29/%E5%9C%A8cursor%E5%AE%89%E8%A3%85deepseek%E6%A8%A1%E5%9E%8B.html" rel="alternate" type="text/html" title="如何在Cursor中安装DeepSeek模型" /><published>2024-12-29T00:00:00+01:00</published><updated>2024-12-29T00:00:00+01:00</updated><id>http://localhost:4000/ai%20tools/2024/12/29/%E5%9C%A8cursor%E5%AE%89%E8%A3%85deepseek%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/ai%20tools/2024/12/29/%E5%9C%A8cursor%E5%AE%89%E8%A3%85deepseek%E6%A8%A1%E5%9E%8B.html"><![CDATA[<p>Cursor作为一款集成AI功能的IDE，使用体验非常丝滑。然而，当赠送的额度用完后，还希望能够继续使用AI功能。DeepSeek作为一款很棒的AI模型，特别其v3版本在网页端表现优异。本文将介绍如何在Cursor中通过API使用DeepSeek模型。</p>

<h2 id="准备工作">准备工作</h2>
<ol>
  <li><strong>获取API Key</strong>
    <ul>
      <li>访问<a href="https://www.deepseek.com">DeepSeek官网</a></li>
      <li>购买API服务（500万tokens仅需10元人民币，支持支付宝付款）</li>
      <li>记录下获取的API Key</li>
    </ul>
  </li>
</ol>

<h2 id="配置步骤">配置步骤</h2>

<h3 id="第一步添加deepseek模型">第一步：添加DeepSeek模型</h3>
<ol>
  <li>打开Cursor的设置界面</li>
  <li>进入”模型”设置</li>
  <li>添加新模型，命名为<code class="language-plaintext highlighter-rouge">deepseek-chat</code></li>
  <li><strong>重要</strong>：取消勾选其他所有模型，仅保留<code class="language-plaintext highlighter-rouge">deepseek-chat</code>。不做的话后面验证API会报错。</li>
</ol>

<h3 id="第二步配置api">第二步：配置API</h3>
<ol>
  <li>在”OpenAI API Key”字段中，粘贴购买的DeepSeek API Key</li>
  <li>在”Base URL”字段中填写：<code class="language-plaintext highlighter-rouge">https://api.deepseek.com/v1</code>
    <ul>
      <li>注意：必须准确填写，如果是别的模型地址，会导致验证报错。</li>
    </ul>
  </li>
  <li>点击验证按钮</li>
  <li>如果没有报错，说明配置成功，可以开始使用</li>
</ol>]]></content><author><name></name></author><category term="AI tools" /><summary type="html"><![CDATA[Cursor作为一款集成AI功能的IDE，使用体验非常丝滑。然而，当赠送的额度用完后，还希望能够继续使用AI功能。DeepSeek作为一款很棒的AI模型，特别其v3版本在网页端表现优异。本文将介绍如何在Cursor中通过API使用DeepSeek模型。]]></summary></entry><entry><title type="html">粒子在一维盒子中</title><link href="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E7%B2%92%E5%AD%90%E5%9C%A8%E4%B8%80%E7%BB%B4%E7%9B%92%E5%AD%90%E4%B8%AD.html" rel="alternate" type="text/html" title="粒子在一维盒子中" /><published>2024-12-29T00:00:00+01:00</published><updated>2024-12-29T00:00:00+01:00</updated><id>http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E7%B2%92%E5%AD%90%E5%9C%A8%E4%B8%80%E7%BB%B4%E7%9B%92%E5%AD%90%E4%B8%AD</id><content type="html" xml:base="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E7%B2%92%E5%AD%90%E5%9C%A8%E4%B8%80%E7%BB%B4%E7%9B%92%E5%AD%90%E4%B8%AD.html"><![CDATA[<p>本节将求解一维盒子中粒子的时间无关薛定谔方程。这里的“一维盒子”指的是粒子在x轴上受到一个势能函数的作用，该势能在长度为l的线段外处处为无穷大，而在线段内势能为零。虽然这种系统在物理上可能显得不现实，但该模型可以成功地应用于某些共轭分子；参见问题2.17。我们将坐标原点放在线段的左端（图2.1）。</p>

<h2 id="区域划分">区域划分</h2>

<p>我们需要考虑三个区域。在区域I和III中，势能V等于无穷大，时间无关薛定谔方程（1.19）为：</p>

\[-\frac{\hbar^2}{2m}\frac{d^2\psi}{dx^2} = (E - \infty)\psi\]

<p>忽略E与无穷大相比，我们得到：</p>

\[\frac{d^2\psi}{dx^2} = \infty\psi, \quad \psi = \frac{1}{\infty}\frac{d^2\psi}{dx^2}\]

<p>因此，我们得出结论，盒子外的ψ为零：</p>

\[\psi_I = 0, \quad \psi_{III} = 0 \tag{2.9}\]

<p>对于区域II，x在零到l之间，势能V为零，薛定谔方程（1.19）变为：</p>

\[\frac{d^2\psi_{II}}{dx^2} + \frac{2m}{\hbar^2}E\psi_{II} = 0 \tag{2.10}\]

<p>其中m是粒子的质量，E是粒子的能量。我们认识到（2.10）是一个常系数的线性齐次二阶微分方程。辅助方程（2.7）给出：</p>

\[\begin{align}
&amp; s^2 + 2mE\hbar^{-2} = 0 \\
&amp; s = \pm (-2mE)^{1/2}\hbar^{-1} \tag{2.11} \\
&amp; s = \pm i(2mE)^{1/2}/\hbar \tag{2.12}
\end{align}\]

<p>其中i = √(-1)。使用（2.8），我们得到：</p>

\[\psi_{II} = c_1e^{i(2mE)^{1/2}x/\hbar} + c_2e^{-i(2mE)^{1/2}x/\hbar} \tag{2.13}\]

<p>暂时令：</p>

<p>\(\theta \equiv (2mE)^{1/2}x/\hbar\)
\(\psi_{II} = c_1e^{i\theta} + c_2e^{-i\theta}\)</p>

<p>我们有 $e^{i\theta} = \cos \theta + i \sin \theta$ [方程（1.28）] 和 $e^{-i\theta} = \cos(-\theta) + i \sin(-\theta) = \cos \theta - i \sin \theta$，因为：</p>

\[\cos(-\theta) = \cos \theta \quad \text{且} \quad \sin(-\theta) = -\sin \theta \tag{2.14}\]

<p>因此，</p>

\[\begin{align}
\psi_{\Pi} &amp;= c_{1}\cos\theta + ic_{1}\sin\theta + c_{2}\cos\theta - ic_{2}\sin\theta \\
&amp;= (c_{1} + c_{2})\cos\theta + (ic_{1} - ic_{2})\sin\theta \\
&amp;= A\cos\theta + B\sin\theta
\end{align}\]

<p>其中 $A$ 和 $B$ 是新的任意常数。因此，</p>

\[\psi_{\Pi} = A\cos[\hbar^{-1}(2mE)^{1/2}x]\,+\,B\sin[\hbar^{-1}(2mE)^{1/2}x] \tag{2.15}\]

<p>现在我们通过应用边界条件来找到 $A$ 和 $B$。假设波函数是连续的似乎是合理的；也就是说，它不会在值上发生突然跳跃（见图3.4）。如果 $\psi$ 在点 $x = 0$ 处连续，那么 $\psi_I$ 和 $\psi_{II}$ 必须在 $x = 0$ 处趋近于相同的值：</p>

\[\begin{align}
\lim_{x \to 0} \psi_I &amp;= \lim_{x \to 0} \psi_{II} \\
0 &amp;= \lim_{x \to 0} \{A \cos [\hbar^{-1}(2mE)^{1/2}x] + B \sin [\hbar^{-1}(2mE)^{1/2}x]\} \\
0 &amp;= A
\end{align}\]

<p>因为</p>

\[\sin 0 = 0 \quad \text{且} \quad \cos 0 = 1 \tag{2.16}\]

<p>当 $A = 0$ 时，方程 (2.15) 变为</p>

\[\psi_{II} = B \sin [(2\pi/h)(2mE)^{1/2}x] \tag{2.17}\]

<p>在 $x = l$ 处应用连续性条件，我们得到</p>

\[B \sin [(2\pi/h)(2mE)^{1/2}l] = 0  \tag{2.18}\]

<p>$B$ 不能为零，因为这将使波函数在所有地方都为零——我们将得到一个空盒子。因此，</p>

\[\sin [(2\pi/h)(2mE)^{1/2}l] = 0\]

<p>正弦函数的零点出现在 $0, \pm \pi, \pm 2\pi, \pm 3\pi, \ldots = \pm n\pi$。因此，</p>

\[(2\pi/h)(2mE)^{1/2}l = \pm n\pi  \tag{2.19}\]

<p>值 $n = 0$ 是一个特殊情况。从 (2.19) 中，$n = 0$ 对应于 $E = 0$。对于 $E = 0$，辅助方程的根 (2.12) 相等，且 (2.13) 不是薛定谔方程的完整解。为了找到完整的解，我们回到 (2.10)，对于 $E = 0$，它读作 $d^2 \psi_{II}/dx^2 = 0$。积分得到 $d \psi_{II}/dx = c$ 和 $\psi_{II} = cx + d$，其中 $c$ 和 $d$ 是常数。边界条件 $\psi_{II} = 0$ 在 $x = 0$ 处给出 $d = 0$，而在 $x = l$ 处的条件则给出 $c = 0$。因此，$\psi_{II} = 0$ 对于 $E = 0$，所以 $E = 0$ 不是一个允许的能量值。因此，$n = 0$ 是不允许的。</p>

<p>解 (2.19) 得到 $E$，我们有</p>

\[E = \frac{n^2 h^2}{8ml^2} \quad n = 1, 2, 3, \ldots \tag{2.20}\]

<p>只有能量值 (2.20) 允许 $\psi$ 满足在 $x = l$ 处的连续性边界条件。边界条件的应用迫使我们得出结论，能量值是量子化的（图2.2）。这与经典结果形成鲜明对比，经典结果认为盒子中的粒子可以具有任何非负能量。注意，粒子的能量有一个大于零的最小值。最低能量的状态称为基态。能量高于基态能量的状态称为激发态。（在经典力学中，盒子中粒子的最低可能能量为零。经典粒子在盒子内静止不动，动能为零，势能为零。）</p>]]></content><author><name></name></author><category term="DFT理论" /><summary type="html"><![CDATA[本节将求解一维盒子中粒子的时间无关薛定谔方程。这里的“一维盒子”指的是粒子在x轴上受到一个势能函数的作用，该势能在长度为l的线段外处处为无穷大，而在线段内势能为零。虽然这种系统在物理上可能显得不现实，但该模型可以成功地应用于某些共轭分子；参见问题2.17。我们将坐标原点放在线段的左端（图2.1）。]]></summary></entry><entry><title type="html">量子力学中的微分方程</title><link href="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.html" rel="alternate" type="text/html" title="量子力学中的微分方程" /><published>2024-12-29T00:00:00+01:00</published><updated>2024-12-29T00:00:00+01:00</updated><id>http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B</id><content type="html" xml:base="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B.html"><![CDATA[<p>在量子力学中，研究一个粒子在一维系统中的稳态波函数和能级是通过求解时间无关的薛定谔方程（1.19）来实现的。在本章中，我们将对一个非常简单的系统——一维盒子中的粒子（第2.2节）——求解时间无关的薛定谔方程。由于薛定谔方程是一个微分方程，我们首先讨论微分方程。</p>

<h2 id="微分方程">微分方程</h2>

<p>本节仅讨论常微分方程，即只有一个自变量的微分方程。[偏微分方程则有多个自变量。例如，时间相关的薛定谔方程（1.16）中，$t$ 和 $x$ 是自变量。] 常微分方程是涉及自变量 $x$、因变量 $y(x)$ 以及 $y$ 的一阶、二阶、……、$n$ 阶导数（$y’,y’’,\ldots,y^{(n)}$）的关系式。例如：</p>

\[y'' + 2x(y')^2 + y^2 \sin x = 3e^x \tag{2.1}\]

<p>微分方程的阶数是方程中最高导数的阶数。因此，（2.1）式是一个三阶方程。</p>

<p>一种特殊的微分方程是线性微分方程，其形式为：</p>

\[A_n(x)y^{(n)} + A_{n-1}(x)y^{(n-1)} + \cdots + A_1(x)y' + A_0(x)y = g(x) \tag{2.2}\]

<p>其中 $A$ 和 $g$（其中一些可能为零）仅是 $x$ 的函数。在 $n$ 阶线性微分方程（2.2）中，$y$ 及其导数以一次幂出现。不能写成（2.2）形式的微分方程是非线性的。如果（2.2）中的 $g(x) = 0$，则线性微分方程是齐次的；否则是非齐次的。一维薛定谔方程（1.19）是一个线性齐次二阶微分方程。</p>

<p>通过除以 $y’’$ 的系数，我们可以将每个线性齐次二阶微分方程写成以下形式：</p>

\[y'' + P(x)y' + Q(x)y = 0 \tag{2.3}\]

<p>假设 $y_1$ 和 $y_2$ 是两个独立的函数，每个都满足（2.3）。这里的独立意味着 $y_2$ 不是 $y_1$ 的简单倍数。那么线性齐次微分方程（2.3）的通解为：</p>

\[y = c_1y_1 + c_2y_2 \tag{2.4}\]

<h2 id="微分方程的通解与常系数线性齐次方程">微分方程的通解与常系数线性齐次方程</h2>

<p>在求解微分方程时，我们经常需要找到方程的通解。通解通常包含一些任意常数，这些常数可以通过边界条件来确定。边界条件是指在某些点上指定 $y$ 或其导数的值。例如，如果 $y$ 表示一根固定在两点的振动弦的位移，我们知道在这两点上 $y$ 必须为零。</p>

<p>对于一个线性齐次二阶微分方程，如果 $y_1$ 和 $y_2$ 是两个独立的解，那么方程的通解可以表示为：</p>

\[y = c_1 y_1 + c_2 y_2 \tag{2.4}\]

<p>其中 $c_1$ 和 $c_2$ 是任意常数。通过将（2.4）代入方程（2.3）的左边，可以验证这一点：</p>

\[\begin{align}
c_1 y_1'' + c_2 y_2'' &amp; + P(x) c_1 y_1' + P(x) c_2 y_2'  \\
&amp; + Q(x) c_1 y_1 + Q(x) c_2 y_2 = c_1 [y_1'' + P(x) y_1' + Q(x) y_1] \\
&amp; + c_2 [y_2'' + P(x) y_2' + Q(x) y_2] = c_1 \cdot 0 + c_2 \cdot 0 = 0 \tag{2.5}
\end{align}\]

<p>这里利用了 $y_1$ 和 $y_2$ 满足方程（2.3）的事实。</p>

<h2 id="常系数线性齐次方程">常系数线性齐次方程</h2>

<p>一个重要的特殊情况是常系数的线性齐次二阶微分方程：</p>

\[y'' + p y' + q y = 0 \tag{2.6}\]

<p>其中 $p$ 和 $q$ 是常数。为了求解（2.6），我们假设解的形式为 $y = e^{sx}$。指数函数在求导时会重复自身，因此是一个合适的选择。将 $y = e^{sx}$ 代入（2.6）得到：</p>

<p>\(s^2 e^{sx} + p s e^{sx} + q e^{sx} = 0\)
\(s^2 + p s + q = 0 \tag{2.7}\)</p>

<p>方程（2.7）称为辅助方程。它是一个二次方程，有两个根 $s_1$ 和 $s_2$。如果 $s_1$ 和 $s_2$ 不相等，它们将给出方程（2.6）的两个独立解。因此，方程（2.6）的通解为：</p>

\[y = c_1 e^{s_1 x} + c_2 e^{s_2 x} \tag{2.8}\]

<p>例如，对于方程 $y’’ + 6y’ - 7y = 0$，辅助方程是 $s^2 + 6s - 7 = 0$。使用求根公式得到 $s_1 = 1$ 和 $s_2 = -7$，因此通解为 $c_1 e^x + c_2 e^{-7x}$。</p>

<hr />
<p>本文参考自：
Levine, Ira N. “Quantum Chemistry, 58.” PHI Learning Pri. Ltd. Delhi (2013): 461-462.</p>]]></content><author><name></name></author><category term="DFT理论" /><summary type="html"><![CDATA[在量子力学中，研究一个粒子在一维系统中的稳态波函数和能级是通过求解时间无关的薛定谔方程（1.19）来实现的。在本章中，我们将对一个非常简单的系统——一维盒子中的粒子（第2.2节）——求解时间无关的薛定谔方程。由于薛定谔方程是一个微分方程，我们首先讨论微分方程。]]></summary></entry><entry><title type="html">量子力学的历史背景</title><link href="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF.html" rel="alternate" type="text/html" title="量子力学的历史背景" /><published>2024-12-29T00:00:00+01:00</published><updated>2024-12-29T00:00:00+01:00</updated><id>http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF</id><content type="html" xml:base="http://localhost:4000/dft%E7%90%86%E8%AE%BA/2024/12/29/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF.html"><![CDATA[<p>量子力学的发展始于1900年，当时普朗克研究了加热固体发出的光。为了理解这一发展，我们首先需要讨论光的性质。</p>

<h2 id="光的波动性">光的波动性</h2>

<p>1803年，托马斯·杨通过观察光通过两个相邻小孔时的衍射和干涉现象，提供了光具有波动性的有力证据。衍射是波绕过障碍物的现象，而干涉则是两个相同频率的波结合，形成一个新的波，其每一点的扰动是各波在该点扰动的代数和或矢量和。</p>

<h2 id="电磁波理论">电磁波理论</h2>

<p>1864年，詹姆斯·克拉克·麦克斯韦发表了四个方程，即麦克斯韦方程组，统一了电和磁的定律。这些方程预测，加速的电荷会以电磁波的形式辐射能量，电磁波由振荡的电场和磁场组成。麦克斯韦方程预测的这些波的速度与实验测得的光速相同，因此麦克斯韦得出结论：光是一种电磁波。</p>

<p>1888年，海因里希·赫兹检测到了由加速电荷在火花中产生的无线电波，这进一步证实了光确实是电磁波。</p>

<h2 id="电磁波的特性">电磁波的特性</h2>

<p>所有电磁波在真空中的传播速度为 $c = 2.998 \times 10^8 \, \text{m/s}$。电磁波的频率 $\nu$ 和波长 $\lambda$ 之间的关系为：</p>

\[\lambda \nu = c\]

<p>根据频率的不同，电磁波被分为不同的类型，按频率从低到高依次为：无线电波、微波、红外辐射、可见光、紫外辐射、X射线和伽马射线。我们通常用“光”来泛指任何类型的电磁辐射。</p>

<h2 id="黑体辐射">黑体辐射</h2>

<p>在1890年代，物理学家测量了在不同温度下加热的黑体发出的各种频率的光的强度。黑体是一种能够吸收所有照射在其上的光的物体。1896年，物理学家维恩提出了一个描述黑体辐射与光频率和黑体温度之间关系的方程：</p>

\[I = \frac{a\nu^{3}}{e^{b\nu/T}}\]

<p>其中，$a$ 和 $b$ 是经验常数，$Id\nu$ 表示在频率范围 $\nu$ 到 $\nu + d\nu$ 内，黑体每单位时间和单位表面积辐射的能量。维恩的公式与1896年可用的黑体辐射数据吻合得很好，但他的理论解释被认为不够令人满意。</p>

<h2 id="普朗克的量子假说">普朗克的量子假说</h2>

<p>在1900年，物理学家马克斯·普朗克提出了一个公式来解释黑体辐射现象。这个公式是：$I = \frac{a w^3}{e^{b v / T} - 1}$，其中 $I$ 是辐射强度，$w$ 是频率，$T$ 是温度，$a$ 和 $b$ 是常数。这个公式与实验数据非常吻合。</p>

<p>为了找到这个公式的理论依据，普朗克假设黑体中的辐射发射器和吸收器是谐振的电荷（“谐振子”），并且这些谐振子的能量是量子化的。也就是说，能量只能以离散的“能量元素”形式存在，每个能量元素的大小为 $h v$，这意味着能量只能以 $h v$ 的整数倍存在，其中 $h$ 是一个新的物理常数，后来被称为普朗克常数。普朗克发现 $h = 6.6 \times 10^{-34}$ 焦耳·秒。</p>

<p>普朗克的工作通常被认为是量子力学的开端。然而，历史学家们一直在争论普朗克是否真的认为能量量子化是物理现实，还是仅仅是一个数学近似。</p>

<h2 id="爱因斯坦的光电效应理论">爱因斯坦的光电效应理论</h2>

<p>1905年，阿尔伯特·爱因斯坦将能量量子化的概念应用到光电效应中。光电效应是指光照射在金属表面时，会发射出电子。根据经典电磁理论，光的能量与其强度成正比，与频率无关。因此，人们预期电子的动能会随着光强度的增加而增加，但与光的频率无关。</p>

<p>然而，实验观察到电子的动能与光的频率成正比，而与光的强度无关。爱因斯坦提出，光是由粒子状的光子组成的，每个光子的能量为 $h \nu$，其中 $\nu$ 是光的频率。当光子被金属中的电子吸收时，部分能量用于克服金属的束缚力，剩余的能量转化为电子的动能。能量守恒定律给出 $h \nu = \Phi + T$，其中 $\Phi$ 是金属的功函数，$T$ 是电子的最大动能。</p>

<p>光电效应表明，光不仅表现出波动性（如衍射实验所示），还能表现出粒子性。1907年，爱因斯坦将能量量子化的概念应用到固体中原子的振动中。他假设每个原子在每个方向（$x, y, z$）上的振动能量只能是$h \nu_{\text{vib}}$ 的整数倍，其中$\nu_{\text{vib}}$ 是元素的特征振动频率。通过统计力学，爱因斯坦推导出了固体在恒定体积下的热容量$C_v$ 的表达式，并与金刚石的实验数据吻合良好。</p>

<h2 id="原子结构的探索">原子结构的探索</h2>

<p>19世纪末，对放电管和天然放射性的研究揭示了原子和分子由带电粒子组成。电子带负电，质子带正电，且质量是电子的1836倍。1932年发现的中子不带电，质量略大于质子。1909年，卢瑟福、盖革和马斯登通过将α粒子束穿过金属箔并观察其偏转，发现大多数α粒子几乎不受偏转，但少数发生了大角度偏转，甚至被反弹回来。卢瑟福由此得出结论，原子的正电荷集中在一个微小而重的原子核中。</p>

<h2 id="卢瑟福原子模型与玻尔的量子化">卢瑟福原子模型与玻尔的量子化</h2>

<p>1911年，卢瑟福提出了行星模型，认为电子围绕原子核旋转。然而，根据经典电磁理论，加速的带电粒子会辐射能量，导致电子螺旋式坠入原子核，使原子不稳定。1913年，尼尔斯·玻尔提出，氢原子中的电子能量是量子化的，电子只能在某些允许的轨道上运动。当电子从一个轨道跃迁到另一个轨道时，会吸收或发射光子，其频率满足$E_{\text{upper}} - E_{\text{lower}} = h \nu$。玻尔的理论成功解释了氢原子光谱，但无法解释氦光谱和分子中的化学键。</p>

<h2 id="德布罗意与波粒二象性">德布罗意与波粒二象性</h2>

<p>1923年，路易·德布罗意提出电子可能具有波动性，其波长$\lambda = \frac{h}{mv}$，其中$p$ 是动量。1927年，戴维森和革默通过实验证实了电子的波动性。1932年，斯特恩用氦原子和氢分子也观察到了类似现象，表明波动性不仅限于电子，而是微观粒子的普遍特性。</p>

<h2 id="波粒二象性的哲学思考">波粒二象性的哲学思考</h2>

<p>电子和光子都表现出波粒二象性，但它们本质不同。光子以光速$c$ 传播且无静止质量，而电子速度低于$c$ 且有静止质量。经典物理学的概念无法准确描述微观世界的现象。</p>

<hr />
<p>本文参考自：</p>

<p>Levine, Ira N. “Quantum Chemistry, 58.” PHI Learning Pri. Ltd. Delhi (2013): 461-462.</p>]]></content><author><name></name></author><category term="DFT理论" /><summary type="html"><![CDATA[量子力学的发展始于1900年，当时普朗克研究了加热固体发出的光。为了理解这一发展，我们首先需要讨论光的性质。]]></summary></entry></feed>